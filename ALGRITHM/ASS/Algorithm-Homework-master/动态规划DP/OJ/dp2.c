#include <stdio.h>
#include <stdlib.h>

#define M 100
#define N 100
#define K 100

//算法OJ第二题：TOP-K Path 

/*
求解思路：用一个三维数组存储m×n格子的前K个最大得分值，记为a。其中前面两维可以表示位置i，j，第三维表示该位置的前k个得分值。
 用一个二维数组存从(0,0)出发到(m-1,n-1)的路径总数，记为r。
  
首先考虑一个较小情况：m=2，n=2，k=2。i，j分别表示当前位置。第一行第一个数只能到自己，其路径只有一个。往右走，第一行的点
都只有一条路径，即a[0][0][0]，a[0][1][0]存着当前得分的最大值。同样第一列的点也只有一条路径，即a[1][0][0]存着路径得分。
现考察i=1，j=1的情况，先计算下到达该点有多少条路径，一个点的路径数为左面节点和上面节点的路径数之和，即r[1][1] = r[1][0] + r[0][1]。 
其路径得分也有两个，分别是左面节点得分加上自身权重，以及上面节点得分加上自身权重。将这两个值进行比较，取较大值放a[1][1][0]，
较小值在a[1][1][1]。

推广至一般情况：
先考虑r[i][j]，可以先把第一行和第一列的路径都给赋值成1。如果i，j都不为-1，则r[i][j] = r[i][j - 1] + r[i - 1][j]；
***注意：需考虑情况，路径数其实等价于组合数，第m行n列的路径数为C(m, m+n)。当m和n为12时，该数就超过了int类型的最大值2147483647，
这种情况下，r[i][j]再加上一个数，会造成求补（数值溢出变负），导致路径数出现问题，因此要赋值为100。
 
现在考虑路径得分a[i][j][k]，到达该节点只可能从该点左面或者上面来，因此只需考虑左面k个数a[i][j - 1][k]和上面k个数a[i - 1][j][k]
这2k个数的前k个最大值。相当于有A[k]，B[k]两个数组，A和B都已经从大到小排序，此时要求数组C为A和B的前k个最大值。

可以采用归并排序的办法，对A、B、C三个数组分别用标记p, q, s表示当前位置，将A[p]和B[q]比较，大的存到C[s]中，假设较大的为A[p]，
则p++ 和 s++。

a[i][j][k]在从前到后计算的时候，都按照从小到大存，因此可以减少不少开销。 
 
现在说明为什么要计算r[i][j]，因为对于一个m和n可能为100的数组来说，当K=100时，需考虑前面一些点，例如(1,1)，该点只有
2个路径，此时无法计算前100大的数，需要将a[1][1][1]后面的赋值为0或者只计算前2个大数。
该数组就是为了防止将A、B进行归并时，出现越界访问数组的问题。
**该方法不是一个特别好的方法。 

***还有一种好的方法是在创建数组时，将所有的值赋成-1，如果在归并A和B时，遇到当前标记的值为-1，则停止后移。 
 
dp2_another方法与我的类似，其思想基本一致，但更加巧妙和简洁，自己感悟。 
*/ 

int a[M][N][K];
int r[M][N];

/* run this program using the console pauser or add your own getch, system("pause") or input loop */

int main(int argc, char *argv[]) {
	int m, n, k;
	int i, j;
	//memset(a, -1, sizeof a);
	scanf("%d %d", &m, &n);
	scanf("%d", &k);

	r[0][0] = 1;//假定(0,0)到(0,0)就是一条路径 
	for(i = 0; i < m; i++){
		for(j = 0; j < n; j++){
			scanf("%d", &a[i][j][0]);
			int w;
			w = a[i][j][0];
			if(i == 0 && j == 0)
				continue;
			else if (i == 0){
				a[i][j][0] = a[i][j - 1][0] + a[i][j][0]; 
				r[i][j] = r[i][j-1];
			}
			else if(j == 0){
				a[i][j][0] = a[i - 1][j][0] + a[i][j][0];
				r[i][j] = r[i - 1][j];
			}//第一行和第一列的情况，都是直接向下或者向右直接加得分 
			else{
				int tlen = 0, tl = 0, tu = 0;
				if( i< 12 && j <12 )
					r[i][j] = r[i - 1][j] + r[i][j - 1];
				else r[i][j] = 101;
				//当m和n都大于12的时候，路径数的值超过int表示范围 
				int p;
				p = k < r[i][j] ? k : r[i][j];//p表示第[i][j]个点，需要计算前p个最大值。
				
				//归并排序，求前k个极大值 
				while(tlen < p){
					if(a[i - 1][j][tu] > a[i][j - 1][tl] ){
						a[i][j][tlen] = a[i - 1][j][tu] + w;
						tu++;
						tlen++;
						if(tu == r[i - 1][j])
							a[i - 1][j][tu] = -1;// a[i - 1][j][tu] > a[i][j - 1][tl]
					}
					else{
						a[i][j][tlen] = a[i][j - 1][tl] + w;
						tl++;
						tlen++;							
						if(tl == r[i][j - 1])
							a[i][j - 1][tl] = -1;			
					}// a[i - 1][j][tu] < a[i][j - 1][tl]
				}
			} 
		} 
	}
	int tk;
	for(tk = 0; tk < k; tk++){
		if(tk == k - 1){
			
			printf("%d", a[m - 1][n - 1][tk]);
		}
		else
			printf("%d ", a[m - 1][n - 1][tk]);
	}
	return 0;
}

